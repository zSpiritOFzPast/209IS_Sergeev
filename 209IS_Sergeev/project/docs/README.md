- git add. - добавляет изменение в файлах
- git status - даёт понимание какие файлы были изменены добавлены или удалены но не сделан коммит
- git commit -m "описание измененинй" - фиксирует изменение в репозитории сохраняет их в истрию
- git log выводит всю историю коммитов кто что когда изменил
- git show даёт информацию о конкретном коммите  дата автор что изменпилось
- git diff  разница между текущими изменениями и последним коммитом показывает что именно изменнилось в файлах
- git restore отменяет все изменения в файлах возвращает к состоянию последнего  коммита
- git rm удаляет файлы из git и так же из рабочей папки в случае необходимости 
- git reset  отменяет все коммиты и возвращает проект к более раннему этапу 
- git branch показывает список веток
1 git branch "имя ветки" создаём новую вветку 
2 git branch -d "имя ветки" удаляет ветку с названием
- git pull переносит актуальные изменение с гита на наш репозиторий желательно находиться на главной ветке в момент выполнения 
- git help -a показывает все допустимые команды git 
- git clone url скопировать\склонировать удалённый репозаторий 

### понятие репозитория структура проетка.

репозторий это - хранилище кода проетка включ: 1-все файлы и папки проекта 2- историю изменений (коммите) 3-информацию о тегах и настройках
виды репозиториев:1-локальный репозторий храниться на пк разработчика(папка .git) 2-удалённый репрозиторий размещён на сервере (github либо gitlub) 
# базовая структура проектов  git
у всех проектов
название проекта      #корневая папка проекта   
 - .git/ #скрытая папка с данными git

 -scr/ #исходный код
 -dosc/ #документация
 -config/ #файл конфигурации
 -assets/ #ресурсы
 -.gitignore #файл, указывающий, какие файлы git должен игнорировать

 1. не отслеживамые git о них не знает
 2. изменённые это файлы которые были в репозитории но подверглись изменениям
 3. индексированные это файлы которые подготовленны  к комиту(была волпоненна команда git add .)
 4. зафиксированные изменнения сохранены в репозитории (git commit)
 каждое изменение должно быть логичеси завершенно 
 git ignore  обезателен что бы не засорять репозиторий не нужными файлами 
 readme это лицо проекта он должен описание установку и использования но в нашем случае конспект 

 # виды цели и уровни интеграции программных модулей
инеграция программных моулей это - процесс обеденения отдельных компонентов по в единую систему обеспечивающие 

цель интеграции: 
1 обеспечение взаимодейстивия модулей
2 повышение надёжности и производительности систем
3 упрощение разработки и сопровождение ПО
4 минимизация дублировая функционала

# виды интеграции программных модулей 
по способу взаимодействий:
1 горизонтальная интеграция это обеденение модулей одного уровня например взаимодействия между сервисами в микросервисной архитиктуре
2 вертикальной интеграции это обеденение модулей разного уровня 
3 по степени связанности 
1-слабая связаннсть где модули взаимодействуют через стандартные интерфейсы(API сообщение ) что упрощает замену компонентов
примеры rest api и микросервис
2- сильная связанность модули тесно зависят друг от друга изменения одного требует модификации других
пример монолитная архитектура

по времени выполнения: 
1 статическая интеграция компоненты связываются на этапе компиляции
2 динамическая интеграция компоненты связываются во время выполнения
например плагины которые загружаются в ран тайм

# уровни интеграции программных модулей

### уровень данных
интеграция через общие базы данных файлы или очереди сообщений.
примеры:
SQL-базы(MySQL, PostGreSQL)
Брокеры сообщений(RabbitMQ, Kafka)

### Уровень API(Сервисный уровень)
модули взаимодействуют через API(rest, graphQL, gRPC)
Примеры:
веб сервивы(Spring Boot, Flask)
микросервисная архитектура

### Уровень пользовательского интерфейса (UI)
Интеграция через единый интерфейс (веб, мобильные прилоения)
пример Single Page Application (React, Angular)
Dekstop - приложения (Electron, Qt)

### Уровень бизнес логики
интеграция на уровне общих бизнес правил и  процессов
пример
ERP - системы (SAP, IC)
Workflow - движки (Camunda, Airflow)


#инструментальные средства интеграции

### Средства сбоаки и управления зависимостями
-nmp,yarn
-pip

### CI/CD -Инструменты
Gitlab CI Github Actions автомотизация сборки и тестирования
Docker Kubrmetes контейнеризация и оркестрация

# Middleware и брокеры сообщений
RabbitMQ, Apache kafka - Асинхронная интегрыция
Redis - кеширование и Pub/Sub

# Автомотизация бизнес процесса
это использование технологий для выполнения повторяющихся задач
минимизация ручного труда и повышение эфективности работы оргонизации

цель: автомотизации
1 это ускорение выполнение операции 
2 снижение ошибок из-за человеческого фактора
3 оптимизация затрат
4 повышение прозрачности и управляемости процесса
5 маштабируемый бизнес

# виды бизнес процессов по уровню сложности

1-простые процессы это простые процессы без ветвлений
2-это сложные процессы они вкл в себя условие циклы паралельные потоки например при соглосовании договора

# виды бизнес процессов по функциональным областям:
1-облать управление документа оборота пример электронный архив
2-финансы и бухалтерия(автомотизация расчётов и отчётности)
3-логистика и склад это учёт товаров маршутизация доставок

HR -процесы
тех.поддержка

# уровни автомотизации
1-базовый уровень это автомотизация протых задач рассылка email либо sms генерация отчётов и обработка данных
2-средний уровень использования VPM систем это настройка маршрутов соглосования 
3-высокий уровень это работизированная автомотизацию процессов имитация действий пользователя

#Конфигурация Prenttierrc

{
    #"ключ": "значение"

    //Максимальное значение символов в одной строке до переноса текста
    "printwidth": 80,

    // Ширина отступа(количесство пробелов)
    #"tabwidth": 3,

    // Использовать символы табуляции для отступа
    #"usetabs": False,

    // Ставить точки с запятой в конце выражения JS (true - да, False - нет)
    "semi": true,

    // Использовать одинарные '' и двойные кавычки ""
    "singleQuote": false,

    // Правило постановки завершающей запятой(none all es5)
    //none - не добовлять завершающую запятую
    //all - добавлят всегда 
    //es5 - везде где позволяет синтаксис
    "traillingComa": "es5",

    // Оставлять ли пустое пространство внутри квадратных или круглых скобках
    "bracketSpacing": False,

    // Всегда ли заключать аргумент в срелочных функциях в круглые скобки
    // "always" - всегда "avoid" - избегать круглых скобог при одном аргументе
    "arrowParens": "avoid",
}
shift+alt+f

# вид источников и приёмников данных
источник данных это обект или система откуда поступают данные для обработки приёмник данных это обект или система куда да передаются обработанные данные
примеры источников данных:
1-базза данных как SQL так и nosql
2-файлы
3-API
4- потоки данных
примеры приёмников:
1-базза данных
2-отчёты и визуализация
3-внешние системы
4-облачное хранилище
критерии выбора источника и выбора данных
при выборе учитывается:
1- формат данных бывают структурированный полуструктурированный неструктурированный
2-обём данных большие обёмы данных
3-читота обновления и пакетная обработка
    надёжность и доступность
    безопасность и доступ по ролям
    стоимость
сопостовление обектов данных 
    это процесс приобразованния данных между источником и приёмником для совместимости
    этапы сопастовления
    проблемы и решение 
        потеря данныхпри потере данных нужно использовать логирование и мониторинг или например grapha
        оптимизировать запросы

        ### Слайдеры:
            # Owl Carousel 2
            #  Boot Strap Carousel
            #  Slick Slider

### Откладка пограммных продуктов

Откладка - процесс поиска и устранения ошибок в ПО
Откладка критически важна при разработке системного прикладного ПО

# Виды ошибокв программном обеспечении:
1 Синтаксическая
    Нарушение правил языка программирования(Обнаруживается при компеляции)
2 Семантическая
    Некорректная логика, несоответствующая ожиданиям
3 Логическая
    Программа корректно работает, но при этом резульатт неверен
4 Ошибка времени выполнения
    При делении на 0, выход за пределы массива, обращение к недопутсимым адресам
5 ОШибка, зависящие от архитектуры
    Этот вид ошибок возникает при различии разрядности, кеша и многопоточности

# Связь откладки с архитектурой аппартаных средств
    Регисторы процессора исползуются для отслеживания
    Печать - необходимо учитывать особенности адрессации сигментации и особенности выравнивания
 Кеш и кеширование
    Возможные ошибки из-за неучтенной инвалдации кеша
 Многопоточность и многозадачность
    Архитектура CPU ядра и потоки влияют на поведение программы
Аппаратные прерывания
    Взаимодейсвтие программ с внешними устройствами при их обработке
Аппартные точки останова(BreakPoints)
    Испольлзуются в низкоуровневой откладке

# Методы откладки 
Ручная отладка
    Анализ исходного кода, использование print заявлений.Проверка логики выполнений
Отладка с исп. отладчиков
    Инетрактивное выполнение кода. Используются точки останова. Пошаговое установление Вход(StepIn) Выход(StepOut) завершение(StepOver) Проверяются и изменяются значения переменных
Логирование
    Происходит запись кода выполнения программы в журнал или консоль. Происходит анализ поведения без вмешательства в процеес исполнения
Авотматическое тестирование
    Написание юнит тестов интегрированных и регрессивных также автоматическо тестирование
Аппаратная отладка
    Отладка встроенных систем

### Классификация инструментов отладки

# По уровню 
    Высокоуровневые 
        Работают с исходным кодом
    Низкоуровневые
        Рабоате с машинным кодом
    Аппаратные
        используют внешние средтва и интерфейсы отладки
По типы примененния
    Инетрактивне отладчики - инстурменты логирования

        Пограммные инструменты отлдаки и низкоуровнивье
        Кдючивые особенности
        Как работают
        С какими языками программирования взаимодействуют

# Ключевые особенности интерактивных отладчиков:

    1 Отладка в режиме реального времени: Возможность остановки выполнения программы на любом этапе для подробного изучения текущего состояния системы.
    2 Просмотр значений переменных: Отображение текущих значений локальных и глобальных переменных, облегчение понимания контекста возникновения проблемы.
    3 Установка точек останова: Позволяет остановить программу перед выполнением определённого участка кода для детального исследования состояния.
    4 Шаговое исполнение: Запуск программы шаг за шагом, позволяя детально проследить последовательность операций.
    5 Логирование действий: Автоматическое ведение журнала происходящих событий и состояний объектов, помогающее выявить источник ошибок.
    6 Анализ стека вызовов: Предоставляет возможность просмотра цепочки функций, приведших к текущей точке выполнения.

# Процесс отладки включает следующие этапы:

    1 Подготовка среды: Установка точки входа в приложение, определение мест установки контрольных точек (точек останова).
    2 Запуск программы: Начало выполнения программы с возможностью отслеживания всех этапов.
    3 Контрольное событие: Остановка программы на заданной точке для оценки состояния объекта или окружения.
    4 Изучение состояния: Анализ содержимого регистров процессора, памяти, статуса потоков, параметров вызова функций и многого другого.
    5 Продолжение выполнения: После устранения неполадок возобновление нормального хода выполнения программы.
 
# Совместимость с языками программирования

    Python (pdb, ipdb)
    JavaScript/TypeScript (Chrome DevTools, Node.js Inspector) 
    C/C++ (gdb, lldb)
    Go (delve)
    Ruby (pry-debugger)
    PHP (Xdebug)
    Kotlin/Java (IntelliJ IDEA Debugger)
    Rust (rust-gdb, rust-lldb)
    Swift (LLDB в Xcode)

### Программные инстурменты отладки

# Универсальные кросс-платформенные отладчики

gdb (GNU Debugger) — классический инструмент отладки приложений C/C++,
 Fortran, Go и многих других языков. Поддерживает пошаговую отладку,
  установку точек останова, просмотр значений переменных и многое другое.

lldb (Low Level Virtual Machine Debugger) — мощный современный отладчик,
поддерживающий широкий спектр языков, таких как Swift, Objective-C, C++ и другие.
Используется в основном на платформах Apple.

Visual Studio Code Debugger — встроенный отладчик популярного редактора Visual Studio Code,
поддерживает Python, JavaScript, TypeScript, PHP, Ruby, Java и многие другие языки благодаря расширениям.

# Языко-зависимые отладчики
PDB (Python Debugger) — стандартный отладчик для Python,
 позволяет устанавливать точки останова, трассировать код,
 выводить значения переменных и перемещаться между кадрами стека.

Node.js Inspector — интегрированный отладчик для JavaScript-приложений,
 работающих на платформе Node.js. Может использоваться совместно
 с инструментами браузера Chrome DevTools.

XDebug — популярный отладчик для PHP, позволяющий установить точки останова,
 вести профилирование и собирать статистику о выполнении скриптов.

PyCharm Debugger — мощная среда отладки в PyCharm, обеспечивающая полный набор возможностей
 для отладки Python-кода, включая поддержку удалённой отладки.

LLVM LLDB — отладчик среды LLVM, используемый преимущественно
 для проектов на языках семейства C, включая Swift.

Delphi Debugger — встроенная система отладки в среде Delphi,
 предназначенная для Pascal-подобных языков.

Rubymine Debugger — графический интерфейс отладки Ruby-кода в IDE Rubymine.

IntelliJ IDEA Debugger — многофункциональный отладчик для Kotlin, Java,
 Scala и других JVM-языков, входящий в состав IntelliJ IDEA.

# Низкоуровневые отладчики и инструменты логирования
strace / dtrace — утилиты Unix-подобных операционных систем,
 позволяющие следить за системными вызовами и перехватывать события ввода-вывода.

Wireshark — сетевой сниффер, применяемый для анализа трафика и
 обнаружения проблем взаимодействия приложений с сетью.

Valgrind — пакет для анализа памяти и профилирования,особенно полезный для отладки утечек памяти
 и некорректного обращения с памятью в программах на C/C++.

Heap Profiler — компонент Google Chrome DevTools, предназначенный для мониторинга распределения памяти веб-приложениями
 и скриптами JavaScript.

   ### Ручное и автоматизированное тестирование
# Ручное тестирование
    Процесс выполнения тест-кейсов в ручную бнз испльзование автоматизированных инстурментов
        Особенности:
         Тестировщик запускает программу, вводит данные и наблюдает поведение
         Часто применяется на этаппе исследовательского тестирования
         Не требует навыков в программировании
# Приемущесвта ручного тестирования
    Гибкость и адаптивность к неожиданным ситуациям
    Больше подходит к UI UIx и сложных взаимодействий
    Так же применется на начальных этапах проекта
# Недостатки
    Время\ресурснозатратно, возможны человеческие ошибки, плохо масштабируется

# Автоматизированные тестирование
    Использование специальизированных программ ил скриптов для выполненния тестов
        Инструменты:
         Selenium- тестирование веб-интерфейсов
         G-unit и Py-test - unit-тестирование
         Mocha, TestNG и KeyPress- исп. дял JS и веб приложений
         RobotFrameWork- поддерживает ключивое слолвоподобное тестирование
         Appium - для моб.приложений
# Приемущества:
    Быстрое выполнение повторяющихся тестов
    Выскоая точность.
    Легко инетгрируется в CI\CD
    Подходит для регрессивного тестирования
# Недостатки
    Высокие затраты на внедрение.
    Требуются навыки программирования
    Ограниченная гибкость
    Плохо работает с изменяющимся user interface
    Поддержэка автотестов со времинем может стать дорогой.
     ____________________________________________________________________________________
    |    Характеристики        |  Ручное тестирование  | автоматизированое тестирование  |
    |--------------------------|-----------------------|---------------------------------|
    |    Повторяемость         |       Низкая          |    Высокая                      |
    |--------------------------|-----------------------|---------------------------------|
    |    Скорость              |       Низкая          |    Высокая                      |
    |--------------------------|-----------------------|---------------------------------|
    |    Подходит для UI\UIx   |         Да            |    Частично                     |
    |--------------------------|-----------------------|---------------------------------|
    |    Стоимость внедрения   |       Низкая          |    Высокая на старте            |
    |--------------------------|-----------------------|---------------------------------|
    |    Гибкость              |       Высокая         |    Средняя                      |
    |--------------------------|-----------------------|---------------------------------|
    |    Точность              |     Зависит от        |    Высокая                      |
    |                          |    тестировщика       |                                 |
    |--------------------------|-----------------------|---------------------------------|
    |    Масштабироемость      |      Плохая           |    Хорошая                      |
    |__________________________|_______________________|_________________________________|    

# Подходы к выбору типа тестирования
    ____________________________________________
   |  Условия проекта   |Рекомандуемые_подход   |
   |--------------------|-----------------------|
   |Часто меняющийся    | Ручное тестирование   |
   |   интерфейс        |                       |
   |--------------------|-----------------------|  
   |Большое число       | Автоматизированное    |
   |повторяющихся тестов|    тестирование       |
   |--------------------|-----------------------|
   |Краткие срок        |       Ручное или      |
   |Проекта             |   Частично автоматиз. |
   |                    |      тестирование     |
   |--------------------|-----------------------|
   |Инетграции в CI\CD  | Автоматиизированное   |
   |--------------------|-----------------------|
   |Тестирование        |  Смешанный подход     |
   |Физического устр.   |                       |
   |____________________|_______________________|






